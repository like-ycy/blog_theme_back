---
title:      " 运维面试题系列--Redis问题 "
date:       2021-03-03
banner_img: "https://gitee.com/like-ycy/images/raw/master/blog/header.jpg"
tags: [ 面试 ]


---

# Redis 面试问题

### 1、redis主从同步原理

- slave服务器向master发送psync命令（此时发送的是psync ? -1），告诉master我需要同步数据了；
- master接收到psync命令后会进行BGSAVE命令生成RDB文件快照；
- 生成完后，会将RDB文件发送给slave；
- slave接收到文件会载入RDB快照，并且将数据库状态变更为master在执行BGSAVE时的状态一致；
- master会发送保存在缓冲区里的所有写命令，告诉slave可以进行同步了；
- slave执行这些写命令。

### 2、redis 全量同步 部分同步

- 全量同步：
  master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件，与此同时，服务器会缓存所有接收到的来自
  客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器，而slave服务器
  会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存，在此之后master服务器会将在此期间缓存的命令通过redis
  传输协议发送给slave服务器，然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。

- 部分同步：
  从redis 2.8版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master服务器和slave服务器之间都
  是进行全量数据同步，但是从redis 2.8开始，即使主从连接中途断掉，也不需要进行全量同步，因为从这个版本开始融
  入了部分同步的概念。部分同步的实现依赖于在master服务器内存中给每个slave服务器维护了一份同步日志和同步标识，
  每个slave服务器在跟master服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。当主从连接断掉之后，
  slave服务器隔断时间（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的偏移量标识还在master服务
  器上的同步备份日志中，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master
  的同步备份日志中（可能由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），
  则必须进行一次全量更新。在部分同步过程中，master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器
  从而达到数据一致。


### 3、redis的持久化方式

```
aof，rdb 两种持久化方式
```

- #### aof机制

  - **原理：**

    - redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。

  - **文件重写原理：**

    - AOF的方式也同时带来了另一个问题。持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

  - **AOF三种触发机制**

    - 每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好

    - 每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失

    - 不同no：从不同步

  - **优点**

    - AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。
    - AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。

    - AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。

    - AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。

  - **缺点**

    - 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大

    - AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的

    - 以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。

- #### RDB机制

  - **原理**

    - 在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb

  - **触发方式**

    - save：该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。
    - bgsave：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。
    - 自动触发：“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。

  - **优点**

    - RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。

    - 生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。

    - RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

  - **缺点**

    - RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据

### 4、redis两种持久化方式的对比及选择

- **对比**

| 命令       | RDB    | AOF          |
| ---------- | ------ | ------------ |
| 启动优先级 | 低     | 高           |
| 体积       | 小     | 大           |
| 恢复速度   | 快     | 慢           |
| 数据安全性 | 丢数据 | 根据策略决定 |
| 轻重       | 重     | 轻           |

- **选择**

**建议两者同时使用**，剩下的就是看自己的需求了，需求不同选择也不一定。